[TOC]

## 1. 时间复杂度

### 1.1  定义

若存在函数 $f(n)$，使得当 $n$ 趋向无穷大时，$T(n) / f(n)$ 的极限值为不等于 0 的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数，记作 $T(n)=O(f(n))$，称 $O(f(n))$ 为算法的 **渐进时间复杂度**，简称 **时间复杂度**，用大 O 来表示，称为 **大 O 表示法**；

### 1.2 推导时间复杂度的原则

1.  **若运行时间是常数量级，则用常数 1 表示**；
2.  **只保留时间函数中最高阶项**，如 $O(n^2 + 4n)$，保留最高阶项后，成为 $O(n^2)$；
3.  **若最高阶项存在，则省去最高阶项前的系数**，如 $O(4n^2)$，省去最高阶项的系数后，成为 $O(n^2)$；

### 1.3 分析时间复杂度的方法

总结起来，对于如何分析一段代码的时间复杂度，主要有如下 3 个实用方法：

1.  **只关注循环执行次数最多的一行代码**
2.  **加法原则：总复杂度等于量度最大的那段代码的复杂度**
3.  **乘法原则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

### 1.4 常见的时间复杂度曲线

![](https://cdn.jsdelivr.net/gh/cunyu1943/image-hosting-for-blog/image-20200626143247469.png)

### 1.5 常见时间复杂度

#### $O(1)$

即无论执行多少行，都不会影响到其他区域，此时代码的复杂度就是 $O(1)$，如下面的代码中，假设执行每行代码时间都相同切为 $t$，则 2,3 行各需 1 个执行时间，即为 $t + t = 2t。此时执行时间复杂度为常数。

```java
void sayHello(String name){
    System.out.prinln("Hello, " + String);
    System.out.prinln("欢迎关注我的公众号：【村雨遥】");
}
```

#### $O(log n)$

如下列二分查找代码中，通过 `while` 循环，能够成倍的缩减搜索范围，假设需要 `x` 次才能跳出循环，则有 `num * 2 * 2 * ... = n` ，其中 `num` 是常数，有 `n` 个 2 相乘，则有 $num * 2 ^x = n$，从而推出 $x = log_2(n/num)$ ，因此时间复杂度用大 O 表示法表示为 $O(log n)$

```java
int binarySearch(int[] arr, int target){
    int left = 0;
    int right = arr.length - 1;
    while(left <= right){
        int middle = left + (left - right) / 2;
        if(arr[middle] == target){
            return middle;
        }else if(arr[middle] > target){
            right = middle - 1;
        }else {
            left = middle + 1;
        }
    }
    
    return -1;
}
```

#### $O(n)$

如下面这段代码中，`for` 循环中的代码被执行了 `arr.length` 次，因此所需要的时间和数组长度成正比的，因此可以用 $O(n)$ 来表示它的时间复杂度。利用上述推到原则和分析的方法，可以知道下面代码中循环次数最多的是 4,5 行，总的执行时间是 $O(2n)$，抛去系数后，得到最终时间复杂度 $O(n)$.

```java
int sum(int[] arr){
    int total = 0;
    
    for(int i = 0; i < arr.length; i++){
        total += arr[i];
    }
    
    return total;
}
```

#### $O(n log n)$

如果我们将一个复杂度为 $O(logn)$ 的代码重复执行 $n$ 次，那么此时代码的复杂度不就变成 $O(nlogn)$ 了吗

```java
void hello (int n){
  for( int i = 1 ; i < n ; i++){
    int m = 1;
    while( m < n ){
        m *= 2;
    }
   }
}
```

#### $O(n^2)$

假设我们将时间复杂度为 $O(n)$ 的代码重复执行 $n$ 次，那么此时的时间复杂度就是 $n*O(n)$，即可表示为 $O(n^2)$，表现出来就是双重循环的形式

```java
void selectionSort(int[] arr, int n){
    for(int i = 0; i < n; i++){
        int min = i;
        for(int j = i + 1; j < n; j++){
            if(arr[j] < arr[min]){
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
}
```

#### $O(n^3)$

和 $O(n^2)$，类似，将时间复杂度为 $O(n^2)$ 的代码嵌套循环一次，此时复杂度就变成了  $O(n^3)$，表现出来就是三重循环嵌套的形式

```java
void demo(int n){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            for(int k = 0; k < n; k++){
                System.out.print("Hello, World");
            }
            System.out.print("------");
        }
        System.out.print("******");
    }
}
```

#### $O(n!)$

虽然理论上存在时间复杂度为 $O(n!)$ 的算法，但实践中基本遇不到，所以这里就不展开了

## 2. 空间复杂度

### 2.1 定义

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度（即除开原始序列大小的内存，在算法过程中用到的额外的存储空间），反映的对内存占用的趋势，而不是具体内存，也叫作 **渐进空间复杂度** ，**表示算法的存储空间与数据规模间的增长关系**，用 $S(n)$ 来代替；

### 2.2  常用空间复杂度

#### $O(1)$

算法执行所需临时空间不随某一变量 `n` 的大小而变化，则该算法空间复杂度为一个常量，表示为 $S(n) = O(1)$；

```java
int num1 = 1;
int num2 = 2;
int total = num1 + num2;
```

#### $O(n)$

数组占用内存大小为 `n`，而且后续未分配新的空间，因此该算法空间复杂度为 $S(n) = O(n)$；

```java
int[] arr = new int[n];
```

#### $O(n^2)$

二维数组的情况；

```java
int[][] arr = new int[n][n];
```





![](https://gitee.com/cunyu1943/images/raw/master/ImgsUbuntu/20200510234310.png)

---
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

<center><div class="social-share"></div></center>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>