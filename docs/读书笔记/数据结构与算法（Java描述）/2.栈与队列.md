[TOC]

## 1. 栈

栈是存放对象的一种特殊容器，在插入和删除对象时，会遵循后进先出（Last-in-first-out，LIFO）的原则，也即对象可以任意插入栈（入栈，Push），但每次取出的都是此前插入的最后一个对象（退栈，Pop）。

### 1.1 栈支持的方法

栈作为一种抽象数据类型，通常支持如下方法：

| 方法               | 功能描述                                       |
| ------------------ | ---------------------------------------------- |
| `push(Object obj)` | 将对象 `x` 压入栈顶                            |
| `pop()`            | 若栈非空，则将栈顶对象移除并返回移除对象读懂值 |
| `getSize()`        | 获取当前栈中对象的数目                         |
| `isEmpty()`        | 检查栈是否为空                                 |
| `top()`            | 若栈非空，返回栈顶元素（不移除）               |

### 1.2 基于数组的栈实现

```java
/**
 * @author : cunyu
 * @version : 1.0
 * @className : StackBaseArray
 * @date : 2020/7/13 8:48
 * @description : 基于数组的栈实现
 */

public class StackBaseArray {

    // 数组默认容量
    public final static int CAPACITY = 1024;
    // 数组实际容量
    protected int capacity;
    // 对象数组
    protected Object[] s;
    // 栈顶元素位置
    protected int top = -1;

    // 构造函数
    public StackBaseArray() {
        this(CAPACITY);
    }

    public StackBaseArray(int cap) {
        this.capacity = cap;
        s = new Object[this.capacity];
    }

    /**
     * @param
     * @return 当前栈中对象个数
     * @description 获取当前栈中对象个数
     * @date 2020/7/13 8:56
     * @author cunyu1943
     * @version 1.0
     */
    public int getSize() {
        return top + 1;
    }

    /**
     * @param
     * @return true，栈为空；false，栈非空
     * @description 判断栈是否为空
     * @date 2020/7/13 8:59
     * @author cunyu1943
     * @version 1.0
     */
    public boolean isEmpty() {
        return top < 0;
    }

    /**
     * @param object 入栈元素
     * @return
     * @description 入栈
     * @date 2020/7/13 9:07
     * @author cunyu1943
     * @version 1.0
     */
    public void push(Object object) {
        if (getSize() == capacity) {
            System.out.println("溢出");
        }
        // 将位置后移，同时赋值
        s[++top] = object;
    }

    /**
     * @param
     * @return 出栈元素
     * @description 出栈并返回出栈元素
     * @date 2020/7/13 9:07
     * @author cunyu1943
     * @version 1.0
     */
    public Object pop() {
        if (isEmpty()) {
            System.out.println("栈为空");
        }

        Object tmp = s[top];
        // 将出栈位置置为 null，同时位置前移
        s[top--] = null;
        return tmp;
    }

    /**
     * @param
     * @return 栈顶元素
     * @description 获取栈顶元素
     * @date 2020/7/13 9:09
     * @author cunyu1943
     * @version 1.0
     */
    public Object top() {
        if (isEmpty()) {
            System.out.println("栈空");
        }
        return s[top];
    }
}
```

### 1.3 JVM 中的栈

#### 1.3.1 Java 方法栈

任一运行中的 Java 程序均会配备一个私有栈，叫做 **Java 方法栈**，用于记录各个方法在被调用过程中的 **局部变量等重要信息**。具体而言就是 Java 程序执行期，JVM 会维护一个栈，其中元素分别是当前活跃的某一方法实例的描述符，叫做 **帧（Frame）**.

此外，JVM 还设置了一个叫做 **程序计数器** 的变量 PC，用于记录程序在 JVM 中运行到的当前位置。Java 栈中最顶层的帧总是对应当前正在执行的方法实例，其余各帧则是按照自栈顶向上被调用的次序顺序排列。一旦某一方法被调用，该方法对应的帧就会被压入栈中。一旦方法执行完毕，程序计数器就会恢复为该帧中先前保存的位置，然后将该帧出栈，将控制权交给新栈顶对应的方法实例。

## 2. 队列

队列也是对象的一种容器，其中对象的插入和删除均遵循 **先进先出（First-In-First-Out，FIFO）** 原则，也就是说每次删除的只能是最先插入的对象。

### 2.1 队列支持的方法

队列的抽象数据类型就是一个容器，其中对象排成一个序列，只能访问和取出排在最前端（Front）的对象，只能在队列尾部（Rear）插入新对象，一般来讲主要支持如下方法：

| 方法                  | 功能描述                         |
| --------------------- | -------------------------------- |
| `enQueue(Object obj)` | 将元素 `obj` 入队                |
| `deQueue()`           | 若队列非空，将队首元素移除并返回 |
| `getSize()`           | 获取当前队列规模                 |
| `isEmpty()`           | 检查队列是否为空                 |
| `front()`             | 队列非空时，返回队首元素         |

### 2.2 基于数组的队列实现

若是基于顺序数组来实现队列，当每次首元素出队后，都会涉及到元素的移动问题，此时相当于数组元素的移动操作，时间复杂度为 $O(n)$，因此效率很低。为了避免该问题，可以采用循环数组来实现队列，整体思想如下：

引入两个变量 `f` 和 `r`，其中 `f` 始终等于队列首元素在数组中的下标，即指向下次出队元素的位置；而 `r` 则始终等于队列末元素的下标加一，即指向下次入队元素的位置。但是每次元素入队和出队时， `f` 和 `r` 都会增加，最终会超出数组范围，为解决该问题，需要在 `f` 和 `r` 在每次增加后，均以数组长度做取模运算，从而保证所指单元的合法性。相当于将数组头尾相联，构成环状结构。

```java
/**
 * @author : cunyu
 * @version : 1.0
 * @className : QueueBaseArray
 * @date : 2020/7/13 10:08
 * @description : 基于循环数组的队列实现
 */

public class QueueBaseArray {
    // 默认容量
    public static final int CAPACITY = 1024;
    // 数组实际容量
    protected int capacity;
    // 对象数组
    protected Object[] queue;
    // 队首元素位置
    protected int f = 0;
    // 队尾元素位置
    protected int r = 0;

    // 构造方法
    public QueueBaseArray() {
        this(CAPACITY);
    }

    public QueueBaseArray(int cap) {
        this.capacity = cap;
        queue = new Object[capacity];
    }

    /**
     * @param
     * @return 当前队列规模
     * @description 查询当前队列规模
     * @date 2020/7/13 14:55
     * @author cunyu1943
     * @version 1.0
     */
    public int getSize() {
        return (capacity - f + r) % capacity;
    }

    /**
     * @param
     * @return true，队列为空；false，队列非空
     * @description 判断队列是否为空
     * @date 2020/7/13 14:56
     * @author cunyu1943
     * @version 1.0
     */
    public boolean isEmpty() {
        return f == r;
    }

    /**
     * @param object 入队元素
     * @return
     * @description 入队
     * @date 2020/7/13 14:58
     * @author cunyu1943
     * @version 1.0
     */
    public void enQueue(Object object) {
        if (getSize() == capacity - 1) {
            System.out.println("队列已满");
        }
        queue[r] = object;
        // 每次 f 或 r 加 1 后，以数组长度做取模运算，从而保证所指单元的合法性，相当于将数组头尾相联，构成环装结构
        r = (r + 1) % capacity;
    }

    /**
     * @param
     * @return 出队的元素
     * @description 出队
     * @date 2020/7/13 15:03
     * @author cunyu1943
     * @version 1.0
     */
    public Object deQueue() {
        Object element;
        if (isEmpty()) {
            System.out.println("队列为空");
        }

        element = queue[r];
        queue[f] = null;
        // 每次 f 或 r 加 1 后，以数组长度做取模运算，从而保证所指单元的合法性，相当于将数组头尾相联，构成环装结构
        f = (f + 1) % capacity;
        return element;
    }

    /**
     * @param
     * @return 队首元素
     * @description 获取队首元素
     * @date 2020/7/13 15:04
     * @author cunyu1943
     * @version 1.0
     */
    public Object front() {
        if (isEmpty()) {
            System.out.println("队列为空");
        }
        return queue[f];
    }

    /**
     * @param
     * @return
     * @description 遍历队列
     * @date 2020/7/13 15:06
     * @author cunyu1943
     * @version 1.0
     */
    public void traversal() {
        for (int i = f; i < r; i++) {
            System.out.print(queue[i] + "\t");
        }
        System.out.println();
    }
}
```

### 2.3 利用队列结构模拟约瑟夫环

```java
/**
 * @author : cunyu
 * @version : 1.0
 * @className : Jesophus
 * @date : 2020/7/16 8:22
 * @description : 约瑟夫环
 */

public class Jesophus {
    public static Object josephus(QueueBaseArray queue, int k) {
        if (queue.isEmpty()) {
            return null;
        }

        // 不断迭代
        while (queue.getSize() > 1) {
            // 显示当前环
            queue.traversal();
            // 将山芋向前传递 k 次
            for (int i = 0; i < k; i++) {
                queue.enQueue(queue.deQueue());
            }
            // 手拿山芋的孩子退出
            Object obj = queue.deQueue();
            System.out.println("\t" + obj + "退出");
        }
        // 最后剩下的孩子
        return queue.deQueue();
    }

    /**
     * @param a[] 一组对象
     * @return 队列
     * @description 将一组对象组织为一个队列
     * @date 2020/7/16 8:27
     * @author cunyu1943
     * @version 1.0
     */
    public static QueueBaseArray buildQueue(Object a[]) {
        QueueBaseArray queue = new QueueBaseArray();
        for (int i = 0; i < a.length; i++) {
            queue.enQueue(a[i]);
        }
        return queue;
    }

    public static void main(String[] args) {
        String[] kids = {"a43", "c234", "d434", "e543", "g689"};
        System.out.println("幸运儿：" + josephus(buildQueue(kids), 3));
    }
}
```

## 3. 链表

虽然数组十分简单明了，但是由于其长度固定，在空间小了及适应性方面还有些不足，为了消除上述缺陷，于是有了另一种数据结构 -- 链表；

所谓链表（Linked List），就是按照线性次序排列的一组数据节点。

### 3.1 单链表

单链表中，每个节点都是一个对象，通过一个引用 `element` 指向对应数据元素，同时还通过一个引用 `next` 指向下一结点。而其中的第一个和最后一个节点，分别称为链表的 **首节点（Head）** 和 **末节点（Tail）**，其中末节点的 `next` 引用为空，其数据结构实现定义如下：

```java
/**
 * @author : cunyu
 * @version : 1.0
 * @className : Node
 * @date : 2020/7/16 8:57
 * @description : 单链表
 */

public class Node {
    // 数据对象
    private Object element;
    // 后继结点
    private Node next;

    // 构造函数
    public Node() {
    }

    public Node(Object element, Node next) {
        this.element = element;
        this.next = next;
    }

    // Getter & Setter
    public Object getElement() {
        return element;
    }

    public void setElement(Object element) {
        this.element = element;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}
```

#### 3.1.1 首结点的插入和删除

-   插入

要在首结点插入一个节点，那么我们需要先创建一个节点，然后将该节点的 `next` 引用指向原来链表的首结点，同时将队列的 `head` 引用指向我们新插入的节点；

-   删除

要删除首结点，那么我们先要将首结点的 `next` 引用复制一份，接着删除该节点，最后将表头引用 `head` 设置为先前复制的引用即可；

#### 3.1.2 末节点的插入和删除

-   插入

首先创建一个新的节点，然后将其 `next` 引用指向 `null`，并将当前末节点的 `next` 引用指向新插入的节点，最后将 `tail` 引用指向新结点即可。

-   删除

删除尾结点，将 `tail` 引用指向 `null` 即可。

### 3.2 基于单链表实现栈

栈的操作仅限于栈顶元素，将单链表的首节点作为栈顶，其余元素依次排列。

```java
/**
 * @author : cunyu
 * @version : 1.0
 * @className : StackBaseLinkedList
 * @date : 2020/7/16 9:18
 * @description : 基于单链表实现的栈
 */

public class StackBaseLinkedList {
    // 栈顶元素
    protected Node top;
    // 栈中元素规模
    protected int size;

    public StackBaseLinkedList() {
        this.top = null;
        this.size = 0;
    }

    public StackBaseLinkedList(Node top, int size) {
        this.top = top;
        this.size = size;
    }

    /**
     * @param
     * @return 当前栈的规模
     * @description 查询栈规模
     * @date 2020/7/16 9:20
     * @author cunyu1943
     * @version 1.0
     */
    public int getSize() {
        return size;
    }

    /**
     * @param
     * @return true，栈为空；false，栈不为空
     * @description 判断栈是否为空
     * @date 2020/7/16 9:22
     * @author cunyu1943
     * @version 1.0
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * @param element 入栈元素
     * @return
     * @description 压栈
     * @date 2020/7/16 9:24
     * @author cunyu1943
     * @version 1.0
     */
    public void push(Object element) {
        // 新建一个节点，将其作为首节点插入
        Node node = new Node(element, top);
        // 更新栈顶节点引用
        top = node;
        size++;
    }

    /**
     * @param
     * @return 弹出栈顶的元素
     * @description 弹出栈顶
     * @date 2020/7/16 9:28
     * @author cunyu1943
     * @version 1.0
     */
    public Object pop() {
        if (isEmpty()) {
            System.out.println("栈空");
        }

        Object tmp = top.getElement();
        top = top.getNext();
        size--;
        return tmp;
    }

    /**
     * @param
     * @return 栈顶元素
     * @description 查询栈顶元素
     * @date 2020/7/16 9:29
     * @author cunyu1943
     * @version 1.0
     */
    public Object top() {
        if (isEmpty()) {
            System.out.println("栈空");
        }

        return top.getElement();
    }
}
```

### 3.3 基于单链表实现队列



![](https://gitee.com/cunyu1943/images/raw/master/ImgsUbuntu/20200510234310.png)

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

<center><div class="social-share"></div></center>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

