[TOC]

## 1. 题目

102.  [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

## 2. 描述

>   给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
>   **示例：**  
>   二叉树：`[3,9,20,null,null,15,7]`,
>
>   ![](https://img-blog.csdnimg.cn/20200703145915484.png)
>
>   返回其层次遍历结果：
>
>   ```
>   [
>     [3],
>     [9,20],
>     [15,7]
>   ]
>   ```

## 3. 实现方法

### 3.1 方法 1

#### 3.1.1 思路

见代码注释。

#### 3.1.2 实现

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> lists = new ArrayList<List<Integer>>();
    // 根节点为 null，直接返回
    if(root == null){            
        return lists;
    }

    // 根节点不为 null，递归
    dfs(1, root, lists);

    return lists;
}

// index : 层数
public void dfs(int index, TreeNode root, List<List<Integer>> lists){

    // 若 lists 中序列数小于层数，则将 lists 中加入一个空的序列
    if(lists.size() < index){
        lists.add(new ArrayList<Integer>());
    }

    // 然后将当前节点加入 lists 的子序列中
    lists.get(index - 1).add(root.val);

    // 以上就处理完 root 节点
    // 接着处理左右子树即可，处理时，层数到下一次，所以要 +1

    if(root.left != null){
        dfs(index + 1, root.left, lists);
    }

    if(root.right != null){
        dfs(index + 1, root.right, lists);
    }
}
```

![](https://gitee.com/cunyu1943/images/raw/master/ImgsUbuntu/20200510234310.png)

---
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<center><div class="social-share"></div></center>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>