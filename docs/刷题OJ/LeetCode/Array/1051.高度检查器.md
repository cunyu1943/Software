[TOC]

## 1. 题目

[1051. 高度检查器](https://leetcode-cn.com/problems/height-checker/)

## 2. 描述

>   学校在拍年度纪念照时，一般要求学生按照 **非递减** 的高度顺序排列。
>
>   请你返回能让所有学生以 **非递减** 高度排列的最小必要移动人数。
>
>   注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。
>
>   **示例：**
>
>   **输入：** heights = \[1,1,4,2,1,3\]
>
>   **输出：** 3 
>
>   **解释：**
>
>   当前数组：\[1,1,4,2,1,3\]
>
>   目标数组：\[1,1,1,2,3,4\]
>
>   在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。
>
>   在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。
>
>   在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。
>
>   **示例 2：**
>
>   **输入：** heights = \[5,1,2,3,4\]
>
>   **输出：** 5
>
>   **示例 3：**
>
>   **输入：** heights = \[1,2,3,4,5\]
>
>   **输出：** 0

## 3. 实现方法 

### 3.1 方法 1

#### 3.1.1 思路

仔细分析其实可以发现，如果我们将原数组进行排序后，然后将排序后的数组与原数组进行对比，其中索引位置相同但元素不同的个数即为需要移动的次数。此时主要进行的排序（$O(nlogn)$）和遍历操作（$O(n)$），所以最终的时间复杂度为 $O(nlogn)$.

#### 3.1.2 实现

```java
public int heightChecker(int[] heights) {
    // 将原数组复制到一个新数组中
    int[] result = new int[heights.length];
    for (int i = 0; i < heights.length; i++) {
        result[i] = heights[i];
    }

    // 计数
    int count = 0;

    // 新数组排序
    Arrays.sort(result);

    // 对比排序后的新数组和原数组，其中对应索引位置不同的元素个数即为最终结果

    for (int i = 0; i < heights.length; i++) {
        if (result[i] != heights[i]) {
            count++;
        }
    }

    return count;
}
```

![](https://gitee.com/cunyu1943/images/raw/master/ImgsUbuntu/20200510234310.png)

---
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<center><div class="social-share"></div></center>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>